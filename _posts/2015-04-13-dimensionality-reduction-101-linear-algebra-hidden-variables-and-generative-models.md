---
id: 918
title: 'Dimensionality reduction 101: linear algebra, hidden variables and generative models'
date: 2015-04-13T03:14:13+00:00
author: Tiago Ramalho
layout: post
visual: /images/2015/04/digits_PCA-1024x633.png
guid: http://www.nehalemlabs.net/prototype/?p=918
permalink: /blog/2015/04/13/dimensionality-reduction-101-linear-algebra-hidden-variables-and-generative-models/
categories:
  - Science
tags:
  - bayesian
  - code
  - data analysis
  - information theory
  - machine learning
  - python
---
Suppose you are faced with a high dimensional dataset and want to find some structure in the data: often there are only a few causes, but lots of different data points are generated due to noise corruption.
How can we infer these causes? Here I'm going to cover the simplest method to do this inference: we will assume the data is generated by a linear transformation of the hidden causes.
In this case, it is quite simple to recover the parameters of this transformation and therefore determine the hidden (or latent) variables which represent their cause.

<!--more-->

Mathematically, let's say the data is given by a high-dimensional (size N) vector <span>$u$</span> which is generated by a low-dimensional (size M) vector <span>$v$</span> via
<div>$$u=\sum_i^M W_i v_i + \text{noise}$$</div>
 where <span>$W_i$</span> are N-dimensional vectors which encode the transformation.
For simplicity I will assume <span>$u$</span> to have mean value 0.
Let's assume the noise is gaussian.
Then the distribution for the data is
<div>$$P(u|v) = \frac{1}{\sqrt{(2\pi)^N\left|\Sigma\right|}}\exp\left(-\frac{1}{2}(u-W\cdot v)^T \Sigma^{-1}(u-W\cdot v)\right)$$</div>
 with <span>$\Sigma$</span> a diagonal matrix.
This means that we assume any correlation structure in the data arises from the transformation <span>$W$</span>, and not due to noise correlations.
This model is the main feature of the procedure known as <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.FactorAnalysis.html" target="_blank">Factor analysis</a>.

To fit the model we need both the weights <span>$W$</span> and factors <span>$v$</span> which best fit the data (in the case of no prior information for <span>$v$</span>, this corresponds to maximising the <a href="https://en.wikipedia.org/wiki/Likelihood_function" target="_blank">likelihood function</a>).
It is convenient to take the logarithm of the likelihood function:
<div>$$\log P(u|v) = -\frac{1}{2}(u-W\cdot v)^T \Sigma^{-1}(u-W\cdot v) -\frac{1}{2} \log |\Sigma| - \frac{N}{2} \log 2\pi$$</div>


So we are looking for <span>$\arg\max_{W,v,\Sigma} \log P(u|v)$</span>.
The obvious way to obtain the parameters is to use <a href="https://en.wikipedia.org/wiki/Expectation%E2%80%93maximization_algorithm" target="_blank">expectation-maximisation</a>: we calculate what are the factors given <span>$W$</span> and <span>$\Sigma$</span>, and then update those parameters given the new factors in such a way as to maximise the log-likelihood.
Iterating this process will result in convergence to a final set of weights and factors, which will be a local minimum of the likelihood.

Let's examine how this works with a very simple example: the <a href="https://en.wikipedia.org/wiki/Iris_flower_data_set" target="_blank">Iris dataset</a>.
This is a 4 dimensional dataset, with each dimension corresponding to a physical measurement of the sepals and petals of a flower.
There are 3 different flowers so we can assume that each flower's genome will code for different physical features.
So the question is whether there is a 'genome variable' <span>$v$</span> which maps into the observed physical features <span>$u$</span>? Let's load the dataset directly using sklearn:

```python
from sklearn import datasets

iris = datasets.load_iris()
x = iris.data # physical measurements
y = iris.target # actual species for visualization
```

And now we can plug this directly into the Factor analysis model:

```python
import matplotlib.pyplot as plt
from sklearn.decomposition import FactorAnalysis

model = FactorAnalysis(n_components=2)
x_reduced = model.fit_transform(x)
plt.scatter(x_reduced[:, 0], x_reduced[:, 1], c=y, cmap=plt.cm.Paired)
```

Let's visualize the hidden factors for the actual data points we have by inverting the transformation.
Below you can see the data with <span>$v_1$</span> in the x-axis and <span>$v_2$</span> in the y-axis.

<img class="wp-image-924 size-large" src="/images/2015/04/iris_FA-1024x633.png" alt="Factor analysis with 2 components." width="660" height="408" srcset="/images/2015/04/iris_FA-1024x633.png 1024w, /images/2015/04/iris_FA-300x186.png 300w, /images/2015/04/iris_FA-825x510.png 825w, /images/2015/04/iris_FA.png 1455w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px" />

In fact, it seems that the first component <span>$v_1$</span> manages to describe accurately the variation between the 3 different species.
Let's try to do Factor analysis with just one component and see what comes out (I added some randomness in the y-direction to visualize the points better).

<img class="wp-image-930 size-large" src="/images/2015/04/iris_FA_hist-1024x211.png" alt="Factor analysis with 1 component." width="660" height="136" srcset="/images/2015/04/iris_FA_hist-1024x211.png 1024w, /images/2015/04/iris_FA_hist-300x62.png 300w, /images/2015/04/iris_FA_hist.png 1455w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px" />

With 1 component we obtain an estimate for <span>$\Sigma^{-1} = [ 0.16350346, 0.15436415, 0.00938691, 0.04101233]$</span> which corresponds to the variation of the data which is not explained by the linear transformation of <span>$v$</span>.
What if we would force all diagonal elements of <span>$\Sigma$</span> to be identical? In that case, we observe that the vectors <span>$W_i$</span> actually form an _orthogonal_ basis (i.e.
each one is perpendicular to the next).
This in turn means that when we project the data to the space of the hidden variables, each <span>$v_i$</span> will be uncorrelated to the others (which does not happen with Factor analysis).

Linear algebra explains why this happens: after some calculation, we can observe that the obtained <span>$W_i$</span> correspond to the _principal_ eigenvectors (i.e.
are associated to the largest eigenvalues) of the sample covariance matrix <span>$C= \frac{1}{N}\sum_{j=1}^N (u^j - \bar{u}) (u^j-\bar{u})^T$</span> with the overscripts denoting sample index.
This method has a specific name and is called <a href="http://www.miketipping.com/papers/met-mppca.pdf" target="_blank">Probabilistic Principal Components Analysis</a>.
Setting <span>$\Sigma = 0$</span> we obtain the popular vanilla <a href="https://en.wikipedia.org/wiki/Principal_component_analysis" target="_blank">PCA</a>.

Typically we sort the eigenvectors such that <span>$W_1$</span> corresponds to the largest eigenvalue of <span>$C$</span> meaning that the hidden variable <span>$v_1$</span> explains the most variation in the observed data.
Now <span>$W_2$</span> must be perpendicular to <span>$W_1$</span>, which means that <span>$v_2$</span> will explain the most _remaining_ variation in the data, and so on.
If we allow <span>$M=N$</span> then it would be possible to completely reconstruct the data from <span>$v$</span>.

<img class="wp-image-925 size-large" src="/images/2015/04/iris_PCA-1024x633.png" alt="PCA with 2 components." width="660" height="408" srcset="/images/2015/04/iris_PCA-1024x633.png 1024w, /images/2015/04/iris_PCA-300x186.png 300w, /images/2015/04/iris_PCA-825x510.png 825w, /images/2015/04/iris_PCA.png 1455w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px" />

In the Iris dataset we can observe that the projected subspace using probabilistic PCA is different to the one found in Factor analysis.
We can confirm that we found orthogonal components by printing <span>$W_1 \cdot W_2$</span> and comparing it to Factor analysis:

```python
model = PCA(n_components=2)
x_reduced = model.fit_transform(x)
print np.dot(model.components_[0], model.components_[1])
# 3.43475248243e-16

model = FactorAnalysis(n_components=2)
x_reduced = model.fit_transform(x)
print np.dot(model.components_[0], model.components_[1])
# 0.146832660483
```

In the case of handwritten digits, the first two components in PCA appear to capture more of the structure of the problem than the first two factors in factor analysis.
However, since this is a strongly nonlinear problem, none of them can accurately separate all 10 digit classes.

<img class="wp-image-931 size-large" src="/images/2015/04/digits_FA-1024x633.png" alt="Digits with FA" width="660" height="408" srcset="/images/2015/04/digits_FA-1024x633.png 1024w, /images/2015/04/digits_FA-300x186.png 300w, /images/2015/04/digits_FA-825x510.png 825w, /images/2015/04/digits_FA.png 1455w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px" /> <img class="wp-image-932 size-large" src="/images/2015/04/digits_PCA-1024x633.png" alt="Digits with PCA" width="660" height="408" srcset="/images/2015/04/digits_PCA-1024x633.png 1024w, /images/2015/04/digits_PCA-300x186.png 300w, /images/2015/04/digits_PCA-825x510.png 825w, /images/2015/04/digits_PCA.png 1455w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px" />

If we look at the log-likelihood equivalent for PCA we observe a very deep connection: <span>$\log P(u|v) = -\frac{1}{2}(u-W\cdot v)^2$</span>.
The <span>$W, v$</span> that come out of PCA (i.e.
maximise the log-likelihood) also minimize the least squares reconstruction error for the simplest linear model. From a data compression perspective, that means that we can compress the information contained in <span>$u$</span> by saving only <span>$W$</span> and <span>$v$</span>.
This is worth it when we have a large number of samples of <span>$u$</span>, since <span>$W$</span> is constant and each <span>$v$</span> is smaller than each <span>$u$</span>.

With the fit distribution in hand, we can even generate new samples of <span>$u$</span>.
We just need to draw some samples of low-dimensional <span>$v$</span> and pass it through the linear model we have.
Let's see what happens when we apply this idea to the digits dataset, sampling <span>$v$</span> from a gaussian approximation of the <span>$v$</span> corresponding to the actual data distribution.

```python
v = model.transform(x)
v_samples = np.random.multivariate_normal(
    np.mean(v, axis=0), np.cov(v.T), size=100)
x_samples = model.inverse_transform(v_samples)
```

<img class="size-large wp-image-948" src="/images/2015/04/gen_PCA-1024x256.png" alt="Digits from generative distribution.
Given that we are applying a linear model to a nonlinear problem, I'm really happy to be able to make out a few digits!" width="660" height="165" srcset="/images/2015/04/gen_PCA-1024x256.png 1024w, /images/2015/04/gen_PCA-300x75.png 300w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px" />

To finish this long post, let's just look at what happens if we don't assume a flat prior for <span>$v$</span>.
Two common options are to assume <span>$P(v)$</span> is a gaussian or an <a href="https://en.wikipedia.org/wiki/Exponential_distribution" target="_blank">exponential</a> distribution.
Then the log-likelihood (getting rid of constants, as usual) becomes:
<div>$$\log P(u|v) = -\frac{1}{2}(u-W\cdot v)^2 - \alpha v^2 - \beta |v|$$</div>


Those two terms correspond to the often used <span>$L_2$</span> and <span>$L_1$</span> <a href="https://en.wikipedia.org/wiki/Regularization_(mathematics)" target="_blank">regularization</a>, which for linear models have the fancy names of ridge regression and lasso respectively (not really sure why they need fancy names).
Writing this in a more CS notation, we can say that our problem consists of maximising: 
<div>$$||u-W\cdot v||^2 - \alpha ||v||^2 - \beta ||v||$$</div>


This problem has been given the name of <a href="http://web.stanford.edu/~hastie/Papers/spc_jcgs.pdf" target="_blank">Sparse PCA</a>, and we can find an implementation in scikits.
Let's see what happens when we apply it to the digits dataset.

```python
from sklearn.decomposition import SparsePCA
from sklearn import datasets

dset = datasets.load_digits()
x = dset.data
y = dset.target

model = SparsePCA(n_components=10, alpha=0)
x_reduced = model.fit_transform(x)

print np.dot(model.components_[0], model.components_[1])

n_row = 5
n_col = 2
plt.figure(figsize=(6, 15))
for i in xrange(10):
	comp = model.components_[i]
	plt.subplot(n_row, n_col, i + 1)
	vmax = max(comp.max(), -comp.min())
	plt.imshow(comp.reshape([8,8]), cmap=plt.cm.gray, interpolation='nearest')
	plt.xticks(())
	plt.yticks(())
plt.tight_layout()
plt.savefig('digits_SPCA_rec.png')
```

Immediately we notice that we lose the orthogonality of the components due to the constraints.
Let's see how they look like:

<img class="wp-image-934 size-large" src="/images/2015/04/digits_SPCA_rec-410x1024.png" alt="10 components found by sparse PCA." width="410" height="1024" srcset="/images/2015/04/digits_SPCA_rec-410x1024.png 410w, /images/2015/04/digits_SPCA_rec-120x300.png 120w" sizes="(max-width: 410px) 85vw, 410px" />

<a href="https://gist.github.com/tmramalho/ea938b7958d2803227f5" target="_blank">Here is a gist with all the code used for this post.</a>
